# 开 头

## 写在一切之前

##### zkledger主体问题：

银行的交易账本被审计的时候，银行希望不泄露：

- 交易的对象信息
- 每一条交易的具体金额
- 交易图谱（transaction graph）(即不能通过关联多条交易来挖掘出私密信息)

满足上面条件的情况下，能够做到基本的审计功能有：

- **某一个银行在某一时刻拥有多少资产（最基本的功能）**
- 某一个银行平均每一个交易的数额
- 某一个银行所有交易金额的标准差是多少

and知识储备

- [群论（群的定义，性质）]([群 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/群))
- [椭圆曲线(ECC)]([椭圆曲线密码学 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/椭圆曲线密码学))
- [Pedersen承诺(原论文)]([Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing | SpringerLink](https://link.springer.com/chapter/10.1007/3-540-46766-1_9))
- [知乎精简版(“环签名，Pederson承诺，范围证明”）三者之间的关系)]([“环签名、佩德森承诺、范围证明”三者可擦出不一样的火花 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/110013321))



## 系统设计



![1](E:\fadian\系统设计.png)



总共三个主体对象：银行，账本，审计员，其中前两者有自己的数据库，存储自己的私密信息。三者通过分布式账本连在一起。

其中账本中的隐私信息会被隐藏，在上图中打上了阴影。用transaction commitments and proofs代替。



#### 举个例子（论文中的图）

![例子](E:\fadian\例子.png)



**一个交易的所有交易数据都是由该交易的发起者构造和生成**，接收者和交易无关者不需要构造这一行数据，但所有的单元格都要填写，满足 ∑vi = 0。



#### 交易数据大致缩略图



![example2](E:\fadian\example2.png)





### 如何审计一个银行当前资产：

###### 第一种方法（以涉及两个银行交易为例）：

由Pedersen承诺构造以下等式：
$$
(v1*G + r1*H) + (v2*G + r2*H) +…+ (vn*G + rn*H)= v3*G + r3*H
$$


即
$$
\sum_{i=1}^n vi*G+\sum_{i=1}^n ri*H = v3*G+r3*H
$$
其中$\mathcal{v3}$ = $\sum_{i=1}^nvi$ , $\mathcal{r3}$ = $\sum_{i=1}^nri$ , $\mathcal{n}$表示从开始到当前**某个银行**的所有交易数量，$\mathcal{vi}$表示第i交易的数额，$\mathcal{ri}$表示第i交易的盲因子（或者说密钥）。

审计员(auditor)从账本中知道该银行交易的commitment，以及银行告诉审计员的$\mathcal{v3}$和盲因子$\mathcal{r3}$，由审计员验证等式
$$
\sum_{i=1}^n vi+\sum_{i=1}^n ri = v3+r3
$$
若等式成立，则证明该账单没有问题。

但是问题来了：账单表格中的每一行数据是由该交易的发起者构建生成的，其它银行是不知情的，也就是每一个单元格中的盲因子$\mathcal{ri}$ 只有该行交易的发起者知道。这就有问题了，因为根据上面所述的方法，在审计员审计一个银行的时候，需要该银行提供给审计员 。怎么解决这个问题呢？可不可以绕开盲因子$\mathcal{ri}$呢？为了解决这个问题，提出了第二种方法。

### 第二种方法（其实也就是加了一个token的事x）

在每个单元格里面增加一个token，计算方法为$Token_k:= (pk_k)^{r_k} $，其中$p_k$是椭圆曲线上的一点，也是第i银行的公钥，$ri$表示椭圆曲线上的盲因子。根据Pedersen承诺，有
$$
\sum_{i=1}^nCOMM_i = G * \sum_{i=1}^n COMM_i + H * \sum_{i=1}^n ri
$$
so
$$
H * \sum_{i=1}^n ri = \sum_{i=1}^nCOMM_i -  G * \sum_{i=1}^n COMM_i
$$
审计员可以从账本中计算到$\sum_{i=1}^nCOMM_i$，可以从被审计银行那里得到$ G * \sum_{i=1}^n vi$，于是我们可以**绕开$ri$来计算$H *\sum_{i=1}^n ri$ 的值**

令$T = H * \sum_{i=1}^nri$,两边做椭圆曲线乘法运算，乘以x，得
$$
x * T = x *  H * \sum_{i=1}^nri (1)
$$
已知一个单元格的Token表示为$Token_i = (pk_k)^{r_k} $，且私钥生成生成公钥的计算公式为$pk_k =x * H(2) $

其中$pk_k$表示为被审计银行的公钥，所以，某一银行所在列的所有Token的和$Total  Token_i = r1* pk_k + r2 * pk_k  + ... + rn * pk_k = pk_k * \sum_{i=1}^nri = x * H  * \sum_{i=1}^n ri(3) $

由（1）（3）得，$TotalToken_i = x * T$(4)

现在，在(2)(4)式子中，除了x，其它所有变量的值都可以计算的得到，**最后，通过非交互式零知识证明，证明(2)(4)两式所使用的x是相等的。**如果证明为真，审计通过，表示该银行当前拥有 $\sum_{i=1}^nvi$ 的资产。

**小结一下:**第二种方法中，被审计的银行只需要向审计员提供 $\sum_{i=1}^nvi$ 的值即可，不需要提供 $\sum_{i=1}^nvi$ 的值。





#### 补充

##### 资产证明$Π^A$

用来证明这个银行在某一时刻有某数量的资产。

##### 平衡证明$Π^B$

来证明一个转账交易的所有数额之和为0，即 $\sum_{i=1}^nvi=0 $ ，付款者资产减少，收款者资产增加，总和为0.

##### 一致性证明 $Π^C$

上面的证明是基于一个假设前提， $COMM_k(v_i,r_i)$ 和 $Token_i=(pk_k)^{r_k}$ 使用的是相同的$ri$。所以，我们要让交易发起者在构造数据的时候，保证使得两个ri相等。但是我们不信任他，因此我们要求他构造一个一致性证明（proof of consistency），表示为 $Π^C$,并把这个证明保存到每一个单元格中，以便让其它用户认证：如果通过，表示两个式子中的$ri$是相等的

##### 范围证明Range Proof

用来证明交易金额在一定的范围内，比如大于0.这里还涉及到造币和毁币的问题，具体这里不深入。在本论文中，每一个单元格都需要这个证明。

##### 非交互式零知识证明

为了对支付细节做出保护隐私的断言，zkLedger依赖于非交互式零知识证明 （NIZKs）[9]。简而言之，零知识证明涉及两方：持有一些私人数据的验证者和希望确信该私人数据的 某些属性的验证者。例如，验证者可能知道一个承诺cm的开口，并希望说服验证者，承诺值v是在某个 范围内，例如，0≤v<106。使用NIZKs，验证者可以产生一个二进制字符串π，即证明，同时说服验证 者，但不透露关于v的任何其他信息。验证π不需要验证者和验证者之间的任何互动，验证者可以将π附 加到账本上，在那里它可以被系统的任何一方验证。 在理论上，NZK证明系统存在于NP中的所有属性，而NZK的实际可行性则高度依赖于所处理的属性的复 杂性。特别是，循环组中的代数属性，如离散对数的知识，在Pedersen承诺中承诺的数值相等，或类似 的，都有非常有效的NIZK证明系统。zkLedger的设计是精心组织的，因此所有的NIZK证明都有特别有 效的构造。

