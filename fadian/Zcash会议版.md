

## abstract

构建了一个完整的基于账本的数字货币，利用zk-SBNARKs实现

制定构建去中心化的匿名支付方案（DAP）使用户直接私下相互支付并隐藏支付来源，目的地和转账金额

其次，构建Zerocash（Zcash）作为实例

## 1.Introduction

任何人都可以通过区块链中的信息对比特币交易进行去匿名化，可以通过第三方运营池来保护隐私，但有三个限制：延迟大，可被追踪，可被窃取。因此用户需要一个即时，无风险，自动保证的程序去匿名交易

zerocoin

一种去中心化你的混合货币，用户通过Zerocoin协议定期“清洗”bitcoin

1.1.1 性能

兑换零钱需要双重离散对数知识证明，大小超过45kB时需要450ms才能验证（128位）需要每个节点验证并永久储存在账本中，数量级过高

1.1.2功能性

zerocoin缺乏全面匿名支付所需的关键功能：缺乏固定面额的货币无法精确支付，不能分割货币；不能让用户直接用“zerocoins”支付另一个用户；不能隐藏网络上交易金额或其他元数据

解决方案

（1）引入去中心化匿名支付方案，使用zk-SNARKs

（2）通过Zcash系统实现

​	将花费一枚硬币的交易规模减少97.7%

​	交易验证时间减少98.6%

​	允许可变金额的匿名交易

​	隐藏交易金额和用户持有的硬币价值

​	允许直接向用户的固定地址付款（无需用户交互）

A.zk-snark

B.去中心化匿名方案

step1:使用固定价值币的用户匿名，让CMList 表示分类账上所有coin承诺的列表

step2:压缩coin承诺列表，依靠抗冲突散列函数CRH来避免CMList的显示表示。在列表CMList上维护了一个仅基于CRH的MerKle树，rt代表根     （降低时间和空间复杂度降低到对数  depth=64，支持$2^{64}$coins）

step3:拓展直接匿名支付的coin。通过修改coin承诺推导来解决重复铸造问题，并使用伪随机数确定支付目标和推导序列号；重新设计mingting，任何人都可以验证txMint中的cm是价值为$v$的coin承诺（通过检查COMMs(v||k)是否等于cm）但无法辨别所有者或序列号（隐藏在k中）

step4:发送coin。修改地址密钥对结构，（$addr_{pk}$，$addr_{sk}$）

step5:公共输出。修改pour操作以包含公共输出

step6:非延展性。防止对pour交易txPour的可延展性攻击，修改NP语句pour并使用数字签名。

C.Zerocash

Zerocash需要仔细实例化构造的加密成分，以确保zk-SNARK在实践中足够有效

approach:基于SHA256实例化所有必要的加密成分（承诺方案，伪随机数和抗冲突哈希）

fig1

//第二节zk-SNARK的背景知识。第三节中定义了DAP方案，第四节构建。第五节Zerocash中的具体实例化。第六节零现金与现有分类账货币的整合。第七节为我们的原型实现提供了微基准，以及基于全网络模拟的结果。第八节优化。第九节中讨论了并行工作，第十节中总结了我们的贡献和未来的方向。

## 2.zk-SNARK背景

对于场$\mathcal {F} $，运算电路输入与门输出均在$\mathcal F$中，考虑的电路只有双线性门，



